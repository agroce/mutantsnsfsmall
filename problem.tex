The core problem this project aims to address is making the use of program mutants practical in non-research settings, in a way that meets developers' or test engineers' needs; that is, making it possible for someone creating or enhancing a test suite, or developing code and test suite in tandem, to (1) use ``just enough'' mutation testing for their needs, maximizing benefit gained in exchange for work performed, (2) work in any programming language without worrying about the quality of tool support provided for mutation testing, and without sacrificing the ease of understanding of source-based mutants, while easily adding custom mutation operators that target their specific software development task.  More generally, this project aims to make use of the insights of Test-Driven-Development (TDD), and proposes using mutation testing to move beyond a paradigm where developers build a series of tests narrowly tailored to steps in development, and use Mutation-Driven-Development (MDD) to build automated test generators or verification harnesses that handle not only anticipated problems imagined during development, but problems not anticipated by human insight, discovered using mutation-based analysis.  In addition to traditional manual testing, our approach targets both highly-general property-driven testing and even full formal verification of software components, in order to be practical in the future, where software systems will often be so safety- or mission- critical that even ``good'' manual testing is not an acceptable approach to ensuring correctness, security, and reliability.

\subsubsection{Just Enough Mutation Testing: Feedback-Driven Mutation Testing}

Most mutation testing work focuses on computing a mutation score or, at least, the set of unkilled (and perhaps non-equivalent) mutants.  Using mutation testing tools involves running many tests on many modified versions of a software system, and, for larger projects or more expensive test suites, requires substantial computing resources, making reducing that need a major thrust of mutation testing research~\cite{jia2011analysis}.  However, as useful as knowing the overall quality of a test suite may be, the most practical goal of mutation testing is to improve a test suite.  For this purpose, an expensive-to-generate list of all unkilled mutants is not really what users need or want.  A list of unkilled mutants contains uninteresting mutants (many, but not all, equivalent mutants), numerous redundant mutants (that can be killed by the same extension of the test suite, or rejected as uninteresting for the same reason), and a smaller number of actionable, representative mutants that are maximally effective in guiding improvement of a testing effort.  Examining all unkilled mutants is only practical for formal verification efforts or very high-powered test suites and critical software systems that motivate such efforts.  In our own work on using mutants to drive formal verification and automated testing~\cite{groce2015verified,groce2018verified,mutKernel} we note that examining surviving mutants was a time-consuming and unpleasant task, even in these settings.  With a larger number of unkilled mutants, the problem becomes one very much like the bug triage or ``fuzzer taming'' problem in random testing/fuzzing~\cite{PLDI13,SemCrash}:  a user wants to quickly find mutants that indicate the most important ``holes'' in a testing or verification effort, and act on those most-critical gaps, possibly revealing faults in the System Under Test (SUT).

What a user really wants is a tool that presents a few very different, ranked, mutants, all likely to be of interest, and revises the presented mutants and their ranking based on actions taken by the user --- adding tests, fixing faults, marking certain mutants as equivalent or uninteresting, and perhaps assigning a priority and severity to both killed or dismissed mutants and any remaining un-handled mutants. However, current mutation testing approaches make no real effort, with few exceptions~\cite{MutGoogle,FaRM} to prioritize mutants, and none are based on a user-centered feedback loop, where the user and mutation testing framework interact to improve a test suite, automated test generator, or verification harness --- and, of course, improve the SUT as well.  To our knowledge, in fact, other than some efforts to incorporate dominance results~\cite{MutQuality}, no approaches currently suggest any more sophisticated way to maximize the novelty of presented mutants than stratified sampling.

\begin{framed}
{\bf Problem:}  Develop highly automated methods and tools that allow the practical application of mutation testing in a feedback-driven way, where user and mutation testing framework cooperate to improve testing efforts, while minimizing user effort and maximizing the ability to quickly find the most important weaknesses of a test suite, automated test generation system, or formal verification effort.
\end{framed}

\subsubsection{Any-Language Mutation Testing}

\begin{framed}
{\bf Problem:}  Provide high-quality mutation generation support to be used in a maximally flexible but still efficient mutation testing framework that can be applied to (essentially) any language, such that adding project-specific novel mutation operators, or even adding support for a new language (e.g. a DSL used in a single project) is possible for non-expert users.
\end{framed}

\subsubsection{Mutation-Driven Development}

\subsection{PI Qualifications}

PI Groce has been a user of, and contributor to, mutation testing tools for many years.  He combines a long research track record in software testing, including mutation testing, with actual experience testing critical software systems at NASA's Jet Propulsion Laboratory.  PI Groce's long-running interest in improving the state-of-the-art in mutation testing dates from frustration in his efforts to apply mutation tools to the testing and verification effort for the Mars Science Laboratory's flight software, in particular to the file system~\cite{ICSEDiff,CFV08,AMAI}.  This practical orientation informs recent work on using mutation testing in a falsification-driven approach to improving high-end verification and automated testing efforts~\cite{groce2015verified,groce2018verified,mutKernel}.  PI Groce has extensive experience in developing mutation tools for new languages~\cite{le2014mucheck,muupi,regexpMut}, including the first reliable tools for mutation of Haskell, Python, and Swift, as well as in user-facing (vs. researcher-oriented) automated software testing tools~\cite{tstlsttt,DeepState}.