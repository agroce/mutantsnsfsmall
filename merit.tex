The aim of this proposal is to:
\begin{itemize}
\item identify a set of principles for the analysis (formal, static,
  and dynamic) of communication protocols and
  their implementations in embedded systems,
\item implement these theoretical principles in tools usable by
  engineers developing such systems,
\item use these tools to formally, statically, and dynamically analyze networks
  of wireless sensor/actuator nodes deployed in the Southwest Experimental Garden
  Array~\cite{YamEtAl10,FliEtAl12}, a distributed facility for
  examining climatic, genetic, and environmental factors in
  plant ecology.
\end{itemize}


\begin{figure}[!t]
  \centering
  \includegraphics[width=\textwidth]{overview}
  \caption{Overview of the proposed research.}
  \label{fig:overview}
\end{figure}

Figure~\ref{fig:overview} shows the overall concept.  The core
open research problems addressed are represented by two sets of
arrows.  First, an engineering design, modeled as a network of timed
automata (TA), is formally verified with respect to a set of temporal logic specifications.
The timed automaton modeling paradigm together with temporal logics
for system requirements are rich enough for expressing many practical
engineering system designs, including but not limited to communication
protocols and supervisory controls (including those relevant to sensor
networks and IoT systems).  Existing C code that is supposed to
implement the design, and hence satisfy the design specifications, is provided and needs to be verified.
Our goal is to certify whether the C code truly implements the complete TA-based design and, if not, find any bugs in the code.
This is achieved in a sequence of steps:
\begin{enumerate}
\item First, from the TA, \acsl annotations\footnote{\acsl is the
    specification language of \framac{}.} and possibly ghost C code
  (code that does not contribute to runtime semantics, but assists in
  proof construction) are automatically generated to augment the
  implementation code. The annotations together with the ghost code
  sufficiently describe the semantics of the TA; in other words, if
  the annotated specification can be verified then the TA design is implemented correctly by the code.
\item The implementation code with the \acsl annotations and ghost code
  is verified by a static analysis tool, in our case \framac.
  There are three possible outcomes:
  \begin{description}
  \item[verified] The implementation can be formally verified, which means that it correctly implements the TA design and therefore meets the design specifications.
  \item[bugs found] Bugs are found in the implementation, showing that
    it can violate the specifications. In this case, the bugs need to be fixed and the process repeated.
  \item[undecided] The static analysis tool is unable to prove or disprove correctness of the implementation.
  In this case, we continue with the next step.
  \end{description}
\item In the event of an undecided outcome from the static analysis
  step, we attempt to refute correctness (or increase our confidence
  in it) via dynamic analysis --- test case generation.
  Ghost code and runtime assertions as well as a test-harness driver are automatically generated from the
  annotated implementation code to augment the implementation code.
\item The augmented implementation code is then analyzed using the
  \deepstate~\cite{DeepState} framework to apply symbolic execution and graybox fuzzing
  to generate test cases.  These test cases may refute the correctness
  of the design, or they may fail to do so, leaving us more confident
  the system is correct.
\end{enumerate}

\paragraph{Principles:} Assuming that a communication protocol is described
as timed automata~\cite{AD1994:TCS} or probabilistic timed automata,
which satisfy some temporal logic
formulas~\cite{BLM2017:LNCS}, and that it is implemented as a set of
imperative programs, the two main questions are:
\begin{itemize}
\item Given the timed automata and a set of programs supposed to
  implement them, how can we annotate the programs to be able to check
  that they correctly implement the protocol, or to find bugs?
\item Given a set of annotated programs, how can we automatically
  generate a harness (efficiently) representing the test generation problem for that system?
\end{itemize}
For the first problem, we will consider a toy imperative language with the 
usual control structures, unbounded integers, addresses, and 
non-recursive procedures.

Note that these problems differ considerably from the more studied,
but more limited, synthesis problem.  We are not assuming that
system development will involve first producing a formal model, then
using that model to automatically generate an implementation; rather,
we consider the typical real-world scenario, where modeling is a
separate activity, either undertaken after implementation due to
concerns about reliability, or an activity during design that only
indirectly informs the implementation.  That is, the more studied
problem is producing a runtime semantics for a model; we address the
problem of reconciling a model semantics and a runtime semantics,
without unrealistic burden on engineers.


\paragraph{Tools:} In this part we will consider the C programming
language, \framac~\cite{KKP2015:FAC} and \deepstate~\cite{DeepState}
for the analysis of programs, and
\uppaal~\footnote{\url{http://www.uppaal.org}} and
\prism~\cite{KNP2011:CAV}) for the analysis of protocols.  The primary open research questions here are numerous, and include:
\begin{itemize}[itemsep=0pt]
\item How to handle C constructs that are not part of the toy language
\item How to extend existing specification languages to support timing and uncertainty
\item How to assign the same meaning to a specification construct in
  the static \framac context and the dynamic \deepstate context
\item How to handle intra-program parallelism
\item How to effectively translate a failed proof effort in \framac
  into a representation of a testing problem (to find counterexamples
  refuting that proof could be possible) in a dynamic setting
\item How to ensure that the methods are sufficiently automatic
  and behave in ways engineers (not modeling, static, or dynamic
  analysis experts) will expect
\end{itemize}

Our focus will be on \emph{practical} solutions, guided by the
embedded domain experts, rather than on purely theoretical approaches
that do not scale to real systems.  In terms of both principles and
tools, this project aims to make fundamental contributions to both
system design and (specifically) static and dynamic analysis tool
design and specification language design and semantics.